**Как работает хеширование паролей в Spring Security?**

Spring Security использует `PasswordEncoder` для хеширования паролей и их последующего сравнения. Основной механизм построен на одностороннем хешировании, которое делает восстановление оригинального пароля невозможным. Давай разберем весь процесс подробнее.

---

### 1. Хеширование пароля при регистрации

Когда пользователь регистрируется, пароль проходит через `PasswordEncoder`, например, `BCryptPasswordEncoder`. Этот процесс включает несколько шагов:

1. **Добавление соли**: случайная строка ("соль") добавляется к паролю.
2. **Применение хеш-функции**: пароль вместе с солью обрабатывается алгоритмом BCrypt.
3. **Генерация хеша**: на выходе получается зашифрованный пароль, содержащий соль и параметры хеширования.

Пример кода:
```java
PasswordEncoder encoder = new BCryptPasswordEncoder();
String rawPassword = "mySecurePassword";
String hashedPassword = encoder.encode(rawPassword);
System.out.println("Хешированный пароль: " + hashedPassword);
```
Результат может выглядеть так:
```
$2a$10$0GmGixR0sIqOykcO1AsbpeOy.nV4sTYi/hYbMJpHt69sIzLJ6ACp6
```

Этот хеш содержит:
- `$2a$` – версия алгоритма (BCrypt)
- `10$` – параметр "cost factor" (число итераций хеширования)
- Остальная часть – соль и хешированный пароль.

---

### 2. Сравнение паролей при аутентификации

Когда пользователь вводит пароль для входа, система не расшифровывает сохраненный хеш. Вместо этого процесс идет так:

1. **Из базы данных извлекается сохраненный хеш** (например, `$2a$10$...`).
2. **Пользователь вводит "сырой" пароль**.
3. **Вызывается метод `matches()`**, который повторяет хеширование введенного пароля с той же солью и параметрами.
4. **Сравниваются два хеша**:
   - Если совпадают, пароль верный.
   - Если нет, аутентификация проваливается.

Пример кода сравнения:
```java
String rawPassword = "mySecurePassword";
boolean isMatch = encoder.matches(rawPassword, hashedPassword);
System.out.println("Пароль совпадает: " + isMatch);
```

---

### 3. Почему нельзя расшифровать хеш?

Алгоритм BCrypt использует **однонаправленное** хеширование, поэтому обратного преобразования нет. Это защищает пароли от утечек даже при компрометации базы данных.

Если злоумышленник получит хеш, он не сможет восстановить пароль, но может использовать **атаки по словарю** или **перебор**. Однако, соль и высокая сложность хеширования ("cost factor") делают эти атаки крайне медленными.

---

### 4. Дополнительные меры безопасности

1. **Настройка сложности (work factor)** – увеличивает вычислительные затраты:
```java
PasswordEncoder encoder = new BCryptPasswordEncoder(12); // 12 вместо 10 по умолчанию
```

2. **Использование `Argon2` или `PBKDF2`** – альтернативы с усиленной защитой.
3. **Ограничение числа попыток входа** – защита от брутфорса.
4. **Двухфакторная аутентификация (2FA)** – дополнительный уровень защиты.

---

### Итог

- **Пароли хранятся в зашифрованном виде**, а не в открытом тексте.
- **Сравнение выполняется через повторное хеширование** введенного пароля и сравнение с сохраненным хешем.
- **Соль защищает от атак по словарю**, а "cost factor" делает атаку перебором неэффективной.
- **Spring Security упрощает работу с хешированием**, предоставляя удобные API для кодирования и проверки паролей.

Таким образом, Spring Security делает систему аутентификации надежной, даже если хранилище паролей будет скомпрометировано.


